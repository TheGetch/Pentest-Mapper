from burp import IBurpExtender, ITab  # To Create Main Class
import sys  # Required for debugging in BurpSuite
from burp import IContextMenuFactory
from burp import IContextMenuInvocation, IHttpService, IParameter, IMessageEditorController, IHttpRequestResponse
from burp import IMessageEditorTabFactory
from burp import IMessageEditorTab, IExtensionStateListener
from burp import IBurpExtender
from burp import IMessageEditorTabFactory
from burp import IMessageEditorTab
from java.awt import BorderLayout, FlowLayout
from javax import swing
from java import awt
from java.lang import Short
from javax.swing import JMenuItem
import csv

from java.lang import String, Integer, Comparable
from java.util import ArrayList, List
from javax.swing import ListSelectionModel , KeyStroke
from javax.swing.table import DefaultTableModel, AbstractTableModel , TableColumnModel , DefaultTableColumnModel, TableRowSorter
from javax.swing import JTable, JButton, JTextField, GroupLayout, JTabbedPane ,JTextArea, JTextPane, RowFilter
from javax.swing import JScrollPane, JSplitPane, JLabel, AbstractAction, JPopupMenu, JComboBox, DefaultCellEditor
from java.awt import Dimension, GridLayout, Font, Color
import javax.swing.BoxLayout
import javax.swing.Box
from javax.swing import JPanel, JFileChooser, AbstractButton
from javax.swing.filechooser import FileNameExtensionFilter
from javax.swing import JFileChooser
from javax.swing import *
from java.awt import * 
from java.awt.event import *   
from javax.swing.event import TableModelListener
#from java.awt.event import MouseAdapter, MouseListener
from threading import Lock, Timer
from java.awt.event import ActionListener, KeyEvent
from javax.swing.undo import UndoManager, CompoundEdit
#from javax.swing.event import UndoableEditEvent, DocumentListener
from urlparse import urlparse
import time
import os
#import schedule




# Creating Burp Extend Class
class BurpExtender(IBurpExtender, ITab, IContextMenuFactory, AbstractTableModel, IMessageEditorController, TableColumnModel, IExtensionStateListener):
    

    def registerExtenderCallbacks(self, callbacks):
        self.callbacks = callbacks
        self.helpers = callbacks.getHelpers()

        # Allowing debugging
        sys.stdout = callbacks.getStdout()
        sys.stderr = callbacks.getStderr()

        # Informing Burp suite the name of the extension
        callbacks.setExtensionName("Pentest Mapper")
        callbacks.registerExtensionStateListener(self)

        # Creating a output after loading
        callbacks.printOutput("Author: AnoF")
        callbacks.printOutput("Version: 1.5")
        callbacks.printOutput("https://github.com/Anof-cyber/Pentest-Mapper")

        callbacks.registerContextMenuFactory(self)
        #callbacks.registerMessageEditorTabFactory(self)
        


        self.tab = swing.JPanel(BorderLayout())
        self.tabbedPane = swing.JTabbedPane()
        self.tab.add("Center", self.tabbedPane)

        self._log = list()
        #self.vulnlist =list()        
        #self.logEntry = list()
        self._lock = Lock()
        #self.checklistlog = list()
        # Creating Another Tab in the extension tab

        # Creating the First tab named as CheckList
        self.firstTab = swing.JPanel()
        self.firstTab.layout = BorderLayout()
        self.tabbedPane.addTab("CheckList", self.firstTab)
        callbacks.addSuiteTab(self)

        # Creating a Import button in CheckList Tab

        self.buttonPanel = swing.JPanel()
        self.searchchecklist = JTextField('', 15)
        self.buttonPanel.add(self.searchchecklist)
        self.buttonPanel.add(swing.JButton("Search", actionPerformed=self.searchinchecklist))

        #self.buttonPanel.setPreferredSize(Dimension(0, 30))
        # adding the import button with onclick action which refers to the function below
        self.buttonPanel.add(swing.JButton(
            "Import CheckList", actionPerformed=self.importchecklist))
        #self.firstTab.add(Box.createRigidArea(Dimension(35, 0)))
        self.buttonPanel.add(swing.JButton(
            "Create CheckList Item", actionPerformed=self.createtestcases))
        self.buttonPanel.add(swing.JButton(
            "Export CheckList", actionPerformed=self.exportchecklist))
        self.firstTab.add(self.buttonPanel, BorderLayout.PAGE_START)

        # Creating a tab in CheckList tab which will show the data from the import checlist
        self.tablePanel = swing.JPanel()
        #layout = GroupLayout(self.tablePanel)
        #self.tablePanel.setLayout(layout)

        self.comboBox3 = JComboBox()
        self.comboBox3.addItem(None)
        self.comboBox3.addItem('Finding')
        self.comboBox3.addItem('No Finding')
        self.comboBox3.addItem('N/A')

        # creating the table to checklist tab
        self.colNames = ('#', 'Category','Test-Cases','Examples', 'Status')
        #self.data = [['', '', '', '', ''], ]
        self.dataModel = CustomDefaultTableModelHosts(None,self.colNames)
        self.table = JTable(self.dataModel)
        self.table.setAutoCreateRowSorter(True)
        self.table.getColumnModel().getColumn(2).setPreferredWidth(0)
        self.table.getColumnModel().getColumn(1).setPreferredWidth(0)
        self.table.getTableHeader().setReorderingAllowed(False)
        
        comboColumn3 = self.table.getColumnModel().getColumn(4)
        comboColumn3.setCellEditor(DefaultCellEditor(self.comboBox3))
        
        # Delete checklist item
        popupMenu3 = JPopupMenu()
        deleteChecklistItem = JMenuItem("Delete item", actionPerformed=self.deleteitem)
        popupMenu3.add(deleteChecklistItem)
        self.table.setComponentPopupMenu(popupMenu3)

        # adding the table size, width, location and will add the scroller to the table
        self.scrollPane = JScrollPane(self.table)

        # adding search ability
        self.sorter = TableRowSorter(self.dataModel);
        self.table.setRowSorter(self.sorter)

        X_BASE2 = 200  # send to leff
        # 3rd one send to right
        self.scrollPane.setBounds(X_BASE2 + 100, 80, 1200, 800)
        self.scrollPane.setPreferredSize(Dimension(1500, 500))
        self.scrollPane.getViewport().setView((self.table))
        self.tablePanel.add(self.scrollPane)

        # adding the table UI to checklist tab
        self.firstTab.add(self.scrollPane, BorderLayout.CENTER)
        
        # Creating Second Tab
        self.secondTab = swing.JPanel()
        self.secondTab.layout = BorderLayout()
        self.tabbedPane.addTab("API Mapper", self.secondTab)


        # creating UI for button and button in api mapper tab
        self.buttonPanel2 = swing.JPanel()
        self.searchapimapper = JTextField('', 15)
        self.buttonPanel2.add(self.searchapimapper)
        self.buttonPanel2.add(swing.JButton("Search", actionPerformed=self.searchinapimapper))
        #self.buttonPanel2.setPreferredSize(Dimension(0, 30))

        # adding the import button with onclick action which refers to the function below
        self.buttonPanel2.add(swing.JButton(
            "Save Project", actionPerformed=self.savelogger))
        #self.buttonPanel2.add(Box.createRigidArea(Dimension(35, 0)))
        self.buttonPanel2.add(swing.JButton(
            "Load Project", actionPerformed=self.importlogger))
        self.secondTab.add(self.buttonPanel2, BorderLayout.PAGE_START)


        # Creating a UI for table in api mapper tab
        self.tablePanel2 = swing.JPanel()
        #layout = BorderLayout.CENTER(self.tablePanel2)
        #self.tablePanel2.setLayout(layout)


        # not in use still not removed
        self.colNames2 = ('Sr', 'URL', 'Method', 'Post Body',
                          'Functionality Name', 'Request', 'Test Cases')

        self.data2 = [['', ''], ] # not in use still not removed 
       # self.dataModel2 = JTable(MyTableModel())
        

        '''
        creating a menu which will be added with the table in api mapper for right click 
        also assigning a fumction to handle the event when click
        '''
        popupMenu = JPopupMenu()
        sendVulneraility = JMenuItem("Add to Vulnerabilities", actionPerformed=self.sendVulnItem)
        sendRepeaterItem = JMenuItem("Send to Repeater", actionPerformed=self.sendRepeaterItem)
        deleterow = JMenuItem("Delete Row", actionPerformed=self.deleterow)
        popupMenu.add(sendVulneraility)
        popupMenu.add(sendRepeaterItem)
        popupMenu.add(deleterow)
        

        # creating a table with custom model for api mapper
        self.logTable = Table(self)
        

        # allowed colum size for api mapper tab/table
        self.logTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF)
        self.logTable.getTableHeader().setReorderingAllowed(False)
        self.logTable.getColumnModel().getColumn(0).setPreferredWidth(25)
        self.logTable.getColumnModel().getColumn(1).setPreferredWidth(400)
        self.logTable.getColumnModel().getColumn(2).setPreferredWidth(50)
        self.logTable.getColumnModel().getColumn(3).setPreferredWidth(750)
        self.logTable.getColumnModel().getColumn(4).setPreferredWidth(142)
        self.logTable.setRowSelectionAllowed(True)

        #adding a right click menu in the table in api mapper
        self.logTable.setComponentPopupMenu(popupMenu)



        # Creating a scroller for table in api mapper and also width hight for table
        self.scrollPane2 = JScrollPane(self.logTable)
        X_BASE3 = 1  # send to leff
        #self.scrollPane2.setBounds(X_BASE3 + 10, 20, 1900, 570)  # 3rd one send to right
        #self.scrollPane2.setPreferredSize(Dimension(1500, 700))
        self.scrollPane2.getViewport().setView((self.logTable))
        self.sorter2 = TableRowSorter(self);
        self.logTable.setRowSorter(self.sorter2)

        #self.tablePanel2.add(self.scrollPane2, BorderLayout.WEST)


        
        # creating a save test case button and UI and a split pane
        self.CommentsSplitPane = JSplitPane(JSplitPane.VERTICAL_SPLIT);
        self.bottomviewpanel = swing.JPanel()
        self.buttonPanel3 = swing.JPanel(FlowLayout(FlowLayout.LEADING, 10, 10))
        self.buttonPanel3.add(swing.JButton(
            "Save TestCases", actionPerformed=self.SaveTestCases))
        

        #crearting a text box for test cases
        self.testcases = JTextPane()
        self.testcases.setContentType("text/plain");
        self.testcases.setEditable(True)
        penTesterCommentBoxScrollPane = JScrollPane(self.testcases)

        # creating a split in test cases to add button and text box
        self.CommentsSplitPane.setTopComponent(self.buttonPanel3)
        self.CommentsSplitPane.setBottomComponent(penTesterCommentBoxScrollPane);
   
       

        # creating a message editor from burp to show request 
        self.requestViewer = callbacks.createMessageEditor(None, True)
        self.responseViewer = callbacks.createMessageEditor(None, True)
        #self._txtInput = callbacks.createTextEditor()
        #self._txtInput.setEditable(True)
        
       
       #adding the tapped pane to create request and test cases 
        self.editor_view = JTabbedPane()
        self.editor_view.addTab("Request", self.requestViewer.getComponent())
        #self.editor_view.addTab('Test Cases', self._txtInput.getComponent())
        self.editor_view.addTab("Response", self.responseViewer.getComponent())
        self.editor_view.addTab('Test Cases', self.CommentsSplitPane)

        # self.buttonPanel3.add

        # creating a split in api mapper with split size
        spl = JSplitPane(JSplitPane.VERTICAL_SPLIT)
        #spl.setResizeWeight(.7)


        # adding the UI for split pane in api mapper tab

        #spl.setTopComponent(self.tablePanel2)
        #spl.setBottomComponent(self.editor_view) - replaced with left right
        spl.setLeftComponent(self.scrollPane2)
        spl.setRightComponent(self.editor_view)
        #spl.setBottomComponent(editorviews(self)) -replaced with left right

        # adding the spilt part to api mapper tab
        self.secondTab.add(spl)

        # addinf the burp Defalut UI customization for the api mapper tab
        self.callbacks.customizeUiComponent(spl)
        self.callbacks.customizeUiComponent(self.logTable)
        self.callbacks.customizeUiComponent(self.scrollPane2)
        self.callbacks.customizeUiComponent(self.editor_view)


        # creating a new tab 
        self.ThirdTab = swing.JPanel()
        self.ThirdTab.layout = BorderLayout()
        self.tabbedPane.addTab("Vulnerabilities", self.ThirdTab)    


        # creating the button and button location and width in vulnerability tab
        self.buttonPanel4 = swing.JPanel()
        self.searchvulnerability = JTextField('', 15)
        self.buttonPanel4.add(self.searchvulnerability)
        self.buttonPanel4.add(swing.JButton("Search", actionPerformed=self.searchinvulnerability))

        #self.buttonPanel4.setPreferredSize(Dimension(0, 30))
        # adding the import button with onclick action which refers to the function below
        
        #self.buttonPanel4.add(Box.createRigidArea(Dimension(35, 0)))
        self.buttonPanel4.add(swing.JButton(
            "Export Vulnerabilities", actionPerformed=self.exportvulnerability))
        self.buttonPanel4.add(swing.JButton(
            "Import Vulnerabilities", actionPerformed=self.importvulnerability))

        # adding the button in vulnerability tab
        self.ThirdTab.add(self.buttonPanel4, BorderLayout.PAGE_START)



        # creating the UI pannel for vulnerability tab --> table
        self.tablePanel3 = swing.JPanel()
        #layout = GroupLayout(self.tablePanel3)
        #self.tablePanel3.setLayout(layout)


        # Creating a jcombobox that will show the selection option, and adding and none or empty item for selection
        self.comboBox = JComboBox()
        self.comboBox.addItem(None)
        #self.comboBox.setEditable(True)
        #self.comboBox.addActionListener(self.seachincombobox)

        vulnerability_list = ['Broken Access Control','Cryptographic Failures','Insecure Design','Security Misonfiguration','Vulenrable and Outdated Components','Identification and Authentication Failures','Software and Data Integrity Failures','Security Logging and Monitoring Failures','Server-Side Request Forgery (SSRF)','SQL Injection (SQLi)','Directory Traversal','Command Injection','Business logic flaw','Information Disclosure','File Upload Vulnerability','XXE Injection','Cross-Site Scripting (XSS)','Cross-Site Request Forgery (CSRF)','Cross-Origin Resource Sharing (CORS)','Clickjacking','DOM-based Vulnerability','WebSocket Vulnerability','Insecure Deserialization','Server-Side Template Injection','Web Cache Poisoning','HTTP Host Header Vulnerability','HTTP Request Smuggling','OAuth Vulnerability','JSON Web Token (JWT) Vulnerability']
        
        for vuln in vulnerability_list:
            self.comboBox.addItem(str(vuln))        

        self.comboBox2 = JComboBox()
        #self.Severity = ['Very High','High','Medium', 'Low', 'Very Low']
        self.comboBox2.addItem(None)
        self.comboBox2.addItem('Very High')
        self.comboBox2.addItem('High')
        self.comboBox2.addItem('Medium')
        self.comboBox2.addItem('Low')
        self.comboBox2.addItem('Very Low')

        # creating the table to vulnerability tab
        self.colNames3 = ('URL', 'Parameters','Vulnerability','Severity')
        self.dataModel2 = CustomDefaultTableModelHosts2(None,self.colNames3)
        self.table3 = JTable(self.dataModel2)
        self.table3.setAutoCreateRowSorter(True)
        self.table3.getColumnModel().getColumn(2).setPreferredWidth(0)
        self.table3.getColumnModel().getColumn(1).setPreferredWidth(0)
        self.table3.getTableHeader().setReorderingAllowed(False)

        comboColumn = self.table3.getColumnModel().getColumn(2)
        comboColumn.setCellEditor(DefaultCellEditor(self.comboBox))
        comboColumn2 = self.table3.getColumnModel().getColumn(3)
        comboColumn2.setCellEditor(DefaultCellEditor(self.comboBox2))
        #self.sorter3 = TableRowSorter(self.dataModel2);
        #self.table3.setRowSorter(self.sorter3)

        popupMenu2 = JPopupMenu()
        deletevulnerability = JMenuItem("Delete Vulnerability", actionPerformed=self.deletevuln)
        sendToRepeater = JMenuItem("Send to Repeater", actionPerformed=self.sendVulnToRepeater)
        popupMenu2.add(sendToRepeater)
        popupMenu2.add(deletevulnerability)
        self.table3.setComponentPopupMenu(popupMenu2)        

        # adding the table size, width, location and will add the scroller to the table
        self.scrollPane3 = JScrollPane(self.table3)
        X_BASE3 = 1  # send to leff
        # 3rd one send to right
        self.scrollPane3.setBounds(X_BASE3 + 10, 20, 1900, 850)
        self.scrollPane3.setPreferredSize(Dimension(1500, 700))
        self.scrollPane3.getViewport().setView((self.table3))
        self.tablePanel3.add(self.scrollPane3)

        # adding the table UI to vulnerability tab
        self.ThirdTab.add(self.scrollPane3, BorderLayout.CENTER)

        # Creating the config tab
        self.FourthTab = swing.JPanel()
        self.FourthTab.layout = BorderLayout()
        self.tabbedPane.addTab("Config", self.FourthTab) 
        self.buttonPanel5 = swing.JPanel()

        layout = javax.swing.GroupLayout(self.buttonPanel5)
        self.buttonPanel5.setLayout(layout)

        jButton1 = swing.JButton("Choose Directory", actionPerformed=self.Autosavepath)
        jLabel1 = javax.swing.JLabel()
        #button1 = swing.JButton("ChooseDirectory", actionPerformed=self.Autosavepath)
        self.autosavepath = javax.swing.JLabel();
        self.timeperid = javax.swing.JLabel();
        self.timerbox = javax.swing.JTextField(5);
        jLabel4 = javax.swing.JLabel();
        button2 = swing.JButton("Choose File", actionPerformed=self.Autosavepath2)
        self.Checklistfilepath = javax.swing.JLabel()
        #Checklistfilepath.setText("jLabel2")
        Savechecklistfileconfig = swing.JButton("Save Path", actionPerformed=self.saveautoconfigdata2)

        self.saveconfigbutton = swing.JButton("Save Config", actionPerformed=self.saveautoconfigdata)
        jLabel1.setText("Select the Auto Save Output Directory")

        self.timeperid.setText("Set the Time Interval for Auto Save");

        self.timerbox.setText("self.timerbox");

        self.timeerror = javax.swing.JLabel();
        importall = javax.swing.JButton("Import All", actionPerformed=self.autoimportall);
        jSeparator1 = javax.swing.JSeparator();
        jSeparator2 = javax.swing.JSeparator();
        jSeparator1.setPreferredSize(Dimension(50, 100));

        jSeparator2.setPreferredSize(Dimension(50, 100))
        AutoSaveConfigHeading = javax.swing.JLabel()
        AutoloadChecklistHeading = javax.swing.JLabel();
        Exportall = javax.swing.JButton("Export All", actionPerformed=self.autoexportall);
        AutoSaveConfigHeading.setFont(Font("Segoe UI", 1, 14));
        AutoSaveConfigHeading.setText("Auto Save Config");
        AutoSaveConfigHeading.setToolTipText("");

        AutoloadChecklistHeading.setFont(Font("Segoe UI", 1, 14))
        AutoloadChecklistHeading.setText("Auto Load Checklist");
        AutoloadChecklistHeading.setToolTipText("")


        jLabel4.setText("Select Auto Load Checklist File")
        
        
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(35, 35, 35)
                        .addComponent(AutoSaveConfigHeading))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(26, 26, 26)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(AutoloadChecklistHeading)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(self.autosavepath)
                            .addComponent(jButton1)
                            .addComponent(jLabel1)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(importall)
                                .addGap(18, 18, 18)
                                .addComponent(Exportall))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(self.timeperid)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(self.timerbox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(self.timeerror))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(138, 138, 138)
                                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(31, 31, 31)
                                .addComponent(self.saveconfigbutton))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel4)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(button2))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(107, 107, 107)
                        .addComponent(self.Checklistfilepath))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(79, 79, 79)
                        .addComponent(Savechecklistfileconfig)))
                .addContainerGap(128, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(AutoSaveConfigHeading)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jButton1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(self.autosavepath)
                .addGap(12, 12, 12)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(self.timeperid)
                    .addComponent(self.timerbox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(self.timeerror))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(self.saveconfigbutton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(16, 16, 16))
                    .addComponent(AutoloadChecklistHeading, javax.swing.GroupLayout.Alignment.TRAILING))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel4)
                    .addComponent(button2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(self.Checklistfilepath)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(Savechecklistfileconfig)
                .addGap(3, 3, 3)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(importall)
                    .addComponent(Exportall))
                .addGap(85, 85, 85))
        );
   



        self.FourthTab.add(self.buttonPanel5)#,BorderLayout.NORTH)
        #self.FourthTab.add(self.buttonPanel6, BorderLayout.PAGE_START)
        #self.FourthTab.add(self.buttonPanel7,BoxLayout.Y_AXIS)

        self.path = callbacks.loadExtensionSetting('path')
        self.time = callbacks.loadExtensionSetting('time')
        self.checklistpath = callbacks.loadExtensionSetting('checklistpath')
        self.timerbox.setText(self.time)
        self.autosavepath.setText(self.path)

        self.callbacks.printOutput(self.time)
        self.callbacks.printOutput(self.path)
        self.autoloadchecklist = 0
        self.autosavelocation = 0
        self.extensionload = True
        if self.time == None:
            self.time = 1
            self.timerbox.setText(str(self.time))
        else:
            pass

        if self.path == None:
            self.path = "Please select the Directory"
            self.autosavepath.setText(self.path)
        else:
            pass

        if self.checklistpath == None:
            self.callbacks.printOutput(str(self.checklistpath))
            self.Checklistfilepath.setText("Select the Checklist file")
        else:
        #    pass

        #if not self.checklistpath == None:
            ###self.comboBox.removeAllItems()
            ###self.comboBox.addItem(None)
            self.dataModel.setRowCount(0)

            with open(self.checklistpath, 'rb') as f:
                reader2 = csv.reader(f,  delimiter=',')
                #self.data1 = list(reader)
                for rows in reader2:
                    SR = rows[0]
                    category = rows[1]
                    testCase = rows[2]
                    checklistExamples = rows[3]
                    checklistStatus = rows[4]
                    obj = [SR,category,testCase,checklistExamples,checklistStatus]
                    #checklistlog.append(title)
                    #rowsss = self.dataModel.getRowCount()
                    #self.callbacks.printOutput(str(rowsss)) 
                    self.dataModel.addRow(obj)
                    ###self.comboBox.addItem(str(testCase))
                f.close()
            self.Checklistfilepath.setText(self.checklistpath)


        #while self.extensionload == True:

        #self.t = Timer(int(self.time) * 60, self.timer)
        #self.t.start()
        #self.t.join()


    #def timer(self):
        
        #self.callbacks.printOutput(str(self.extensionUnloaded)) 
        while self.extensionload == True:
            if os.path.isdir(str(self.path)):
                if self.logTable.getRowCount() > 0:
                #self.path = fileLoad.getPath()
                    fname = "APIMapper"+"."+"csv"
                    fnameWithPath = os.path.join(self.path,fname)
                    if os.path.exists(fnameWithPath):
                        os.remove(fnameWithPath)
                    self.callbacks.printOutput("Saving the API Mapper output")
                    with open(fnameWithPath, 'wb') as loggerdata:
                        writer = csv.writer(loggerdata)
                        for logEntry in self._log:
                    
                        #self.callbacks.printOutput(str(logEntry._sr))
                            writer.writerow([str(logEntry._sr), str(logEntry._url) ,str(logEntry._method) ,str(logEntry._postbody) ,str(logEntry._FunctionalityName) ,str(logEntry._requestResponse) ,str(logEntry._TestCases),(logEntry._response).encode('utf-8').strip()])
                        loggerdata.close()
                else:
                    self.callbacks.printOutput("Skipping the API Mapper, Table is empty")
                if self.dataModel2.getRowCount() > 0:

                    fname2 = "Vulnerability"+"."+"csv"
                    fnameWithPath2 = os.path.join(self.path,fname2)
                    if os.path.exists(fnameWithPath2):
                        os.remove(fnameWithPath2)
                    self.callbacks.printOutput("Saving the Vulnerability output")
                    totalrow = self.dataModel2.getRowCount()   
                    with open(fnameWithPath2, 'wb') as vulnerabilitydata:
                        writer = csv.writer(vulnerabilitydata)
                        for row in range (0, totalrow):
                            url = self.dataModel2.getValueAt(row,0)
                            paramter = self.dataModel2.getValueAt(int(row),1)
                            Vulnerability = self.dataModel2.getValueAt(int(row),2)
                            Severity = self.dataModel2.getValueAt(int(row),3)
                        #self.callbacks.printOutput(str(url))
                    
                    #self.callbacks.printOutput(str(logEntry._sr))
                            writer.writerow([str(url), str(paramter) ,str(Vulnerability),str(Severity)])
                        vulnerabilitydata.close()
                else:
                    self.callbacks.printOutput("Skipping the  Vulnerability, Table is empty")
            else:
                self.autosavepath.setText("Output Directory doesn't exist")
            time.sleep(int(self.time) * 60)
      

    def extensionUnloaded(self):
        self.extensionload = False
        #self.t.cancel()

    def autoimportall(self,e):
        if os.path.isdir(str(self.path)):
            fname = "APIMapper"+"."+"csv"
            fnameWithPath = os.path.join(self.path,fname)
            if os.path.exists(fnameWithPath):
                with open(fnameWithPath, 'rb') as f:

                    reader2 = csv.reader(f,  delimiter=',')
                
                    for rows in reader2:
                        SR = rows[0]
                        url = rows[1]
                        method = rows[2]
                        body = rows[3]
                        functionname = rows[4]
                        request = rows[5]
                        testcases = rows[6]

                        try:
                            response = rows[7]
                        except IndexError:
                            response = None
                            
                        self._log.append(LogEntry(SR,url, method,body,request,functionname,testcases,response))
                        #self.fireTableRowsInserted(row, row)
                        #self.callbacks.printOutput(str(len(self._log)))
                    f.close()
                    self.fireTableDataChanged()
            fname2 = "Vulnerability"+"."+"csv"
            fnameWithPath2 = os.path.join(self.path,fname2)
            if os.path.exists(fnameWithPath2):
                with open(fnameWithPath2, 'rb') as f:
                    reader2 = csv.reader(f,  delimiter=',')
                    #self.data1 = list(reader)
                    for rows in reader2:
                        URL = rows[0]
                        Parameter = rows[1]
                        Vulnerability = rows[2]
                        
                        try:
                            Severity = rows[3]
                        except IndexError:
                            Severity = None
                        obj = [URL,Parameter,Vulnerability,Severity]
     
                        self.dataModel2.addRow(obj)
                        
                    f.close()


        else:
            self.autosavepath.setText("Output Directory doesn't exist")



    def autoexportall(self,e):
        if os.path.isdir(str(self.path)):
                if self.logTable.getRowCount() > 0:
                #self.path = fileLoad.getPath()
                    fname = "APIMapper"+"."+"csv"
                    fnameWithPath = os.path.join(self.path,fname)
                    if os.path.exists(fnameWithPath):
                        os.remove(fnameWithPath)
                    self.callbacks.printOutput("Saving the API Mapper output")
                    with open(fnameWithPath, 'wb') as loggerdata:
                        writer = csv.writer(loggerdata)
                        for logEntry in self._log:
                    
                        #self.callbacks.printOutput(str(logEntry._sr))
                            writer.writerow([str(logEntry._sr), str(logEntry._url) ,str(logEntry._method) ,str(logEntry._postbody) ,str(logEntry._FunctionalityName) ,str(logEntry._requestResponse) ,str(logEntry._TestCases),(logEntry._response).encode('utf-8').strip()])
                        loggerdata.close()
                else:
                    self.callbacks.printOutput("Skipping the API Mapper, Table is empty")
                if self.dataModel2.getRowCount() > 0:

                    fname2 = "Vulnerability"+"."+"csv"
                    fnameWithPath2 = os.path.join(self.path,fname2)
                    if os.path.exists(fnameWithPath2):
                        os.remove(fnameWithPath2)
                    self.callbacks.printOutput("Saving the Vulnerability output")
                    totalrow = self.dataModel2.getRowCount()   
                    with open(fnameWithPath2, 'wb') as vulnerabilitydata:
                        writer = csv.writer(vulnerabilitydata)
                        for row in range (0, totalrow):
                            url = self.dataModel2.getValueAt(row,0)
                            paramter = self.dataModel2.getValueAt(int(row),1)
                            Vulnerability = self.dataModel2.getValueAt(int(row),2)
                            Severity  = self.dataModel2.getValueAt(int(row),3)
                        #self.callbacks.printOutput(str(url))
                    
                    #self.callbacks.printOutput(str(logEntry._sr))
                            writer.writerow([str(url), str(paramter) ,str(Vulnerability),str(Severity)])
                        vulnerabilitydata.close()
                else:
                    self.callbacks.printOutput("Skipping the  Vulnerability, Table is empty")
        else:
            self.autosavepath.setText("Output Directory doesn't exist")
        
           

    def Autosavepath(self,e):
        chooseFile = swing.JFileChooser()

        chooseFile.setFileSelectionMode(swing.JFileChooser.DIRECTORIES_ONLY)
        returnedFile = chooseFile.showDialog(self.buttonPanel4, "Output Path")
        if returnedFile == JFileChooser.APPROVE_OPTION:
            fileLoad1 = chooseFile.getSelectedFile()
            self.autosavelocation = fileLoad1.getPath()
        #self.callbacks.printOutput(str(self.filepath2))
        return str(self.autosavelocation)



    def Autosavepath2(self,e):

        chooseFile = JFileChooser()
        filter = FileNameExtensionFilter("csv files", ["csv"])
        chooseFile.addChoosableFileFilter(filter)

        ret = chooseFile.showDialog(self.tab, "Choose file")
        if ret == JFileChooser.APPROVE_OPTION:
            fileLoad = chooseFile.getSelectedFile()
            self.autoloadchecklist = fileLoad.getAbsolutePath()
        return str(self.autoloadchecklist)

    def saveautoconfigdata(self,e):
        #path = self.Autosavepath
        #self.callbacks.printOutput(str(path))
      
        if self.autoloadchecklist == 0:
            self.autoloadchecklist = None
        
        if self.autosavelocation == 0:
            if str(self.timerbox.getText()) == "0":
                self.timeerror.setText("Invalid time")
            else:
                self.path = self.callbacks.loadExtensionSetting('path')
                if os.path.isdir(str(self.path)):
                    self.autosavepath.setText(self.path)
                    self.callbacks.saveExtensionSetting("time", self.timerbox.getText())
                    self.time = self.callbacks.loadExtensionSetting('time')
                else:
                    self.callbacks.printOutput(str(self.autosavelocation))
                    self.autosavepath.setText("Please select the valid path!")
        else:
            if str(self.timerbox.getText()) == "0":
                
                self.timeerror.setText("Invalid time")

            
            else:
            #self.t.cancel()
            #self.t.join()
            #self.callbacks.printOutput(str(self.autosavelocation))
            #self.callbacks.printOutput(str(self.autoloadchecklist))
            #self.callbacks.printOutput(str(self.timerbox.getText()))
                
                self.callbacks.saveExtensionSetting("path", str(self.autosavelocation))
                self.callbacks.saveExtensionSetting("time", self.timerbox.getText())
            #self.callbacks.saveExtensionSetting("checklistpath", str(self.autoloadchecklist))
                self.autosavepath.setText(str(self.autosavelocation))
                self.path = self.callbacks.loadExtensionSetting('path')
                self.time = self.callbacks.loadExtensionSetting('time')
            
            #time.sleep(5)
            #runnig = self.t.is_alive()
            #self.callbacks.printOutput(str(runnig))
            #if self.t.finished:

            #self.t.start()
    def saveautoconfigdata2(self,e):
        if self.autoloadchecklist == 0:
            self.Checklistfilepath.setText("Select the checklist file")
            
        else:
            self.callbacks.saveExtensionSetting("checklistpath", str(self.autoloadchecklist))
            self.Checklistfilepath.setText(self.autoloadchecklist)
            self.Checklistfilepath.setText(str(self.autoloadchecklist))
            
            #self.Checklistfilepath.setForeground(Color(209, 6, 6))


    
        
    # this will send the selected row in api mapper to vulnerability tab
    def sendVulnItem(self,event):
        row = self.logTable.getSelectedRows()
        for rows in row:
            logEntry = self._log[rows]
            self.url = logEntry._url
            obj = [str(self.url), None]
            self.dataModel2.addRow(obj)
            
     # function will handle to send the selected row in API to repeater       
    def sendRepeaterItem(self,event):
        row = self.logTable.getSelectedRows()
              
        for rows in row:
            #self.callbacks.printOutput(str(rows))
            logEntry = self._log[rows]
            fullurl = logEntry._url
            url = urlparse(str(fullurl))
            hostname = url.hostname
            port = url.port
            protocol = url.scheme
            request = self.helpers.stringToBytes(logEntry._requestResponse)
            func = logEntry._FunctionalityName
            if protocol == "https":
                self.callbacks.sendToRepeater(hostname,port, True, request, func)
            else:
                self.callbacks.sendToRepeater(hostname,port, False, request, func)

     # function will handle to send the selected vulnerability row to repeater       
    def sendVulnToRepeater(self,event):
        row = self.table3.getSelectedRows()
              
        for rows in row:
            #self.callbacks.printOutput(str(rows))
            logEntry = self._log[rows]
            fullurl = logEntry._url
            url = urlparse(str(fullurl))
            hostname = url.hostname
            port = url.port
            protocol = url.scheme
            request = self.helpers.stringToBytes(logEntry._requestResponse)
            func = logEntry._FunctionalityName
            if protocol == "https":
                self.callbacks.sendToRepeater(hostname,port, True, request, func)
            else:
                self.callbacks.sendToRepeater(hostname,port, False, request, func)


    # function will handle, delete the row from api mapper
    def deleterow(self,event):

       
        row = self.logTable.getSelectedRows()
        for rows in row:
            #logEntry = self._log[rows]
            self._log.pop(rows)
            self.fireTableDataChanged()
            #totalrow = self.logTable.getRowCount()
            #self.callbacks.printOutput(str(totalrow))       


    def deletevuln(self,e):
        totalvulnrows = self.table3.getSelectedRows()
        #self.callbacks.printOutput(str(totalvulnrows))
        for rows in totalvulnrows[::-1]:
            #self.callbacks.printOutput(str(rows))
            self.dataModel2.removeRow(rows)
        
    def deleteitem(self,e):
        totalitemrows = self.table.getSelectedRows()
        for rows in totalitemrows[::-1]:
            #self.callbacks.printOutput("ROWS BEING DELETED:")
            #self.callbacks.printOutput(str(rows))
            #self.callbacks.printOutput("NUMBER OF ROWS BEING DELETED:")
            #self.callbacks.printOutput(str(totalitemrows))
            self.dataModel.removeRow(rows)
    
    # part of custom table model to get total number of row in the table, it will check the data in the list amd will return when called     
    def getRowCount(self):
        try:
            return len(self._log)
        except:
            return 0

    # this is required to work with AbstractTableModel, this will show return the total columns in API Mapper
    def getColumnCount(self):
        return 5

    # this is required to work with AbstractTableModel, this will show the columns Name for API Mapper table
    def getColumnName(self, columnIndex):
        if columnIndex == 0:
            return "SR"
        if columnIndex == 1:
            return "URL"
        if columnIndex == 2:
            return "Method"
        if columnIndex == 3:
            return "Post Body"
        if columnIndex == 4:
            return "Functionality Name"
        return ""

    # this is required to work with AbstractTableModel, this will show the data in the columns from the list for API Mapper table
    def getValueAt(self, rowIndex, columnIndex):
        self.totalrow = self.logTable.getRowCount()
        if rowIndex < self.getRowCount() and columnIndex < self.getColumnCount():
       
            logEntry = self._log[rowIndex]
            if columnIndex == 0:
                #return logEntry._sr
                return str(rowIndex + 1)
            if columnIndex == 1:
                return logEntry._url
            if columnIndex == 2:
                return logEntry._method
            if columnIndex == 3:
                return logEntry._postbody
            if columnIndex == 4:
                return logEntry._FunctionalityName
            return ""
        else:
            self.callbacks.printError("Table is empty")

    ''' 
    part of custom table for api mapper, it will get the edited value from function column and will save it in the class based list 
    for the selected row

    '''
    def setValueAt(self, value, rowIndex, columnIndex):

        if rowIndex < self.getRowCount() and columnIndex < self.getColumnCount():
                logEntry = self._log[rowIndex]
                logEntry._FunctionalityName = value
        else:
            self.callbacks.printError("Table is empty")
      
    ''''    
    def getHttpService(self):
        return self._currentlyDisplayedItem.getHttpService()

    def getRequest(self):
        return self._currentlyDisplayedItem.getRequest()

    def getResponse(self):
        return self._currentlyDisplayedItem.getResponse()

    '''
    #function that will show a option to send request to extension in proxy/repeater etc
    def createMenuItems(self, invocation):
        ctx = invocation.getInvocationContext()
        menu = []
        menu.append(swing.JMenuItem("Send To API Mapper", None,actionPerformed=lambda x, inv=invocation: self.getTabledataa(inv)))
        menu.append(swing.JMenuItem("Send To Vulnerability", None,actionPerformed=lambda x, inv=invocation: self.getVulnerabilitydataa(inv)))

        if menu == []:
            return
        else:
            return menu


    # function will be called when user send any request to vulnerabilites tab, it will give the selected message
    def getVulnerabilitydataa(self,invocation):
        reqRes = invocation.getSelectedMessages()
        for items in reqRes:
            self.url = items.getUrl()
            obj = [str(self.url), None]
            self.dataModel2.addRow(obj)



    # function will be called when user send any request to the extension, function will get the required data from the request that is send and will add it to the list
    def getTabledataa(self, invocation):
        reqRes = invocation.getSelectedMessages()
        #requestss = IHttpService()
        for items in reqRes:
            req = self.helpers.analyzeRequest(items)
            self.method = req.getMethod()
            #url = req.url
            paramter = req.getParameters()
            domainame = items.getHost()  # - workings
            portnumer = items.getPort()  # workings
            protocol = items.getProtocol()  # workings
            self.url = items.getUrl()
            gettingrequest = items.getRequest()
            self.requestinst = self.helpers.bytesToString(gettingrequest)
            self.responseinbytes = items.getResponse()
            self.responseinst = self.helpers.bytesToString(self.responseinbytes)
            #requestdetails = req.getRequest()
            getody = req.getBodyOffset()
            self.body = self.requestinst[getody:len(self.requestinst)]


            rowss = self.logTable.getRowCount()
            self.sr2 = str((rowss + 1))
            self._lock.acquire()
            row = len(self._log)
            column = self.logTable.getColumnCount()
            self._log.append(LogEntry(self.sr2, self.url, self.method, self.body, self.requestinst, '', '', self.responseinst))
            self.fireTableRowsInserted(row, row)
            self._lock.release()


     # Returning the tab name to Burp Suite
    def getTabCaption(self):
        return "Pentest Mapper"


    # Returning the UI to the extension tab - Returning the new taB insite the extension tab
    def getUiComponent(self):
        #return self.tab
        return self.tabbedPane

    # function will export the table data when clicked on save button in api mapper tab
    def savelogger(self,e):
        currenttime = str(time.strftime('%Y-%m-%d,%H:%M:%S', time.localtime(time.time())))
        chooseFile = swing.JFileChooser()
        chooseFile.setFileSelectionMode(swing.JFileChooser.DIRECTORIES_ONLY)
        returnedFile = chooseFile.showDialog(self.buttonPanel2, "Output Path")
        
        '''
        filter = FileNameExtensionFilter("csv files", ["csv"])
        chooseFile.addChoosableFileFilter(filter)
        returnedFile = chooseFile.showDialog(self.buttonPanel2, "Choose File")
        '''

        

        if returnedFile == JFileChooser.APPROVE_OPTION:
            fileLoad = chooseFile.getSelectedFile()
            #self.filepath = fileLoad.getAbsolutePath()
            self.filepath = fileLoad.getPath()
            fname = "APIMapper"+str(time.time())+"."+"csv"
            fnameWithPath = os.path.join(self.filepath,fname)
           
            with open(fnameWithPath, 'wb') as loggerdata:
                writer = csv.writer(loggerdata)
                for logEntry in self._log:
                    
                    #self.callbacks.printOutput(str(logEntry._sr))
                    writer.writerow([str(logEntry._sr), str(logEntry._url) ,str(logEntry._method) ,str(logEntry._postbody) ,str(logEntry._FunctionalityName) ,str(logEntry._requestResponse) ,str(logEntry._TestCases),(logEntry._response).encode('utf-8').strip()])
            loggerdata.close()


    # function to handle event to import table data in api mapper tab
    def importlogger(self,e):
        chooseFile = JFileChooser()
        filter = FileNameExtensionFilter("csv files", ["csv"])
        chooseFile.addChoosableFileFilter(filter)

        ret = chooseFile.showDialog(self.tab, "Choose file")
        if ret == JFileChooser.APPROVE_OPTION:
            fileLoad = chooseFile.getSelectedFile()
            self.filepath = fileLoad.getAbsolutePath()
            with open(self.filepath, 'rb') as f:
                reader2 = csv.reader(f,  delimiter=',')
                
                for rows in reader2:
                    SR = rows[0]
                    url = rows[1]
                    method = rows[2]
                    body = rows[3]
                    functionname = rows[4]
                    request = rows[5]
                    testcases = rows[6]
                    try:
                        response = rows[7]
                    except IndexError:
                        response = None
                    self._log.append(LogEntry(SR,url, method,body,request,functionname,testcases,response))
                    #self.fireTableRowsInserted(row, row)
                    #self.callbacks.printOutput(str(len(self._log)))
                f.close()
                self.fireTableDataChanged()

    ## Search text in checklist tab            
    def searchinchecklist(self,e):
        checklistsearchstring = self.searchchecklist.getText()
        if checklistsearchstring == "":
            self.sorter.setRowFilter(None)
        else:
            
            self.sorter.setRowFilter(RowFilter.regexFilter("(?i)" + checklistsearchstring));


    ## Search text in APIMapper tab            
    def searchinapimapper(self,e):
        apimappersearchstring = self.searchapimapper.getText()
        if apimappersearchstring == "":
            self.sorter2.setRowFilter(None)
        else:
            
            self.sorter2.setRowFilter(RowFilter.regexFilter("(?i)" + apimappersearchstring));

    ## Search text in Vulnerability tab            
    def searchinvulnerability(self,e):
        vulnerabilitysearchstring = self.searchvulnerability.getText()
        if vulnerabilitysearchstring == "":
            self.sorter3.setRowFilter(None)
        else:
            
            self.sorter3.setRowFilter(RowFilter.regexFilter("(?i)" + vulnerabilitysearchstring));





    #Function that will be called when user click on import in checklist tab
    def importchecklist(self, e):
        
        chooseFile = JFileChooser()
        filter = FileNameExtensionFilter("csv files", ["csv"])
        chooseFile.addChoosableFileFilter(filter)
        
        ret = chooseFile.showDialog(self.tab, "Choose file")
        if ret == JFileChooser.APPROVE_OPTION:
            fileLoad = chooseFile.getSelectedFile()
            self.filepath = fileLoad.getAbsolutePath()
            ###self.comboBox.removeAllItems()
            ###self.comboBox.addItem(None)
            self.dataModel.setRowCount(0)
            with open(self.filepath, 'rb') as f:
                reader2 = csv.reader(f,  delimiter=',')
                #self.data1 = list(reader)
                for rows in reader2:
                    SR = rows[0]
                    category = rows[1]
                    testCase = rows[2]
                    checklistExamples = rows[3]
                    checklistStatus = rows[4]
                    obj = [SR,category,testCase,checklistExamples,checklistStatus]
                    #checklistlog.append(title)
                    #rowsss = self.dataModel.getRowCount()
                    #self.callbacks.printOutput(str(rowsss)) 
                    self.dataModel.addRow(obj)
                    ###self.comboBox.addItem(str(testCase))
                f.close()




            

    # creating a function that will be called when user clicks on the create button this function will show the input field in UI for checklist taB
    def createtestcases(self, e):
        self.textfield1 = JTextField('Category', 15)
        self.textfield2 = JTextField('Test-Case', 15)
        self.textfield3 = JTextField('Example',15)
        self.buttonPanel.add(self.textfield1)
        self.buttonPanel.add(self.textfield2)
        self.buttonPanel.add(self.textfield3)
        self.buttonPanel.add(swing.JButton(
            "Sumit", actionPerformed=self.addrow))
        self.buttonPanel.add(Box.createVerticalGlue())

    # this function will be called as soon as user click on suBmit Button of add row UI input 
    def addrow(self, e):
        rowsss = self.dataModel.getRowCount()
        sr = (rowsss + 1)
        title = self.value = self.textfield1.getText()
        testCase = self.value = self.textfield2.getText()
        example = self.value = self.textfield3.getText()
        obj = [sr, title, testCase, example]
        #checklistlog.append(title)
        ###self.comboBox.addItem(str(testCase))
        #ChecklistLogEntry
        self.dataModel.addRow(obj)
        if not self.checklistpath == None:

        # Writing the new entry in file   
            with open(self.checklistpath, 'a') as writechecklist:
                writer = csv.writer(writechecklist)
                writer.writerow([str(sr), str(title)])
            writechecklist.close()
        else:
            self.callbacks.printOutput("Auto add to csv file only work if auto checklist load is configured") 

    # function to handle event when save button clicked on test cases 
    def SaveTestCases(self,e):
        selectedrow = self.logTable.getSelectedRow()
        if selectedrow >= 0:
            logEntry = self._log[selectedrow]
            Value = self.testcases.getText()
            logEntry._TestCases = Value


    # function will handle to event once the export button clicked on vulnerablity tab
    def exportvulnerability(self,e):
        totalrow = self.dataModel2.getRowCount()
        self.callbacks.printOutput(str(totalrow))
        
        chooseFile = swing.JFileChooser()

        chooseFile.setFileSelectionMode(swing.JFileChooser.DIRECTORIES_ONLY)
        returnedFile = chooseFile.showDialog(self.buttonPanel4, "Output Path")
        #filter = FileNameExtensionFilter("csv files", ["csv"])
        #chooseFile.addChoosableFileFilter(filter)
        #returnedFile = chooseFile.showDialog(self.buttonPanel4, "Choose File")

        if returnedFile == JFileChooser.APPROVE_OPTION:
            fileLoad1 = chooseFile.getSelectedFile()
            self.filepath2 = fileLoad1.getPath()
            fname2 = "Vulnerability"+str(time.time())+"."+"csv"
            fnameWithPath = os.path.join(self.filepath2,fname2)

            #self.filepath2 = fileLoad1.getAbsolutePath()
            with open(fnameWithPath, 'wb') as vulnerabilitydata:
                writer = csv.writer(vulnerabilitydata)
                for row in range (0, totalrow):
                    url = self.dataModel2.getValueAt(row,0)
                    paramter = self.dataModel2.getValueAt(int(row),1)
                    Vulnerability = self.dataModel2.getValueAt(int(row),2)
                    Severity = self.dataModel2.getValueAt(int(row),3)
                    #self.callbacks.printOutput(str(url))
                    
                    #self.callbacks.printOutput(str(logEntry._sr))
                    writer.writerow([str(url), str(paramter) ,str(Vulnerability),str(Severity)])
            vulnerabilitydata.close()

    # function will handle the event once the export button is clicked on checklist tab
    def exportchecklist(self,e):
        totalrow = self.dataModel.getRowCount()
        self.callbacks.printOutput(str(totalrow))
        
        chooseFile = swing.JFileChooser()

        chooseFile.setFileSelectionMode(swing.JFileChooser.DIRECTORIES_ONLY)
        returnedFile = chooseFile.showDialog(self.buttonPanel, "Output Path")

        if returnedFile == JFileChooser.APPROVE_OPTION:
            fileLoad1 = chooseFile.getSelectedFile()
            self.filepath2 = fileLoad1.getPath()
            fname2 = "Checklist"+str(time.time())+"."+"csv"
            fnameWithPath = os.path.join(self.filepath2,fname2)

            with open(fnameWithPath, 'wb') as checklistdata:
                writer = csv.writer(checklistdata)
                for row in range (0, totalrow):
                    checklistNumber = self.dataModel.getValueAt(row,0).encode('utf-8').strip()
                    checklistCategory = self.dataModel.getValueAt(int(row),1).encode('utf-8').strip()
                    checklistTestCase = self.dataModel.getValueAt(int(row),2).encode('utf-8').strip()
                    checklistExample = self.dataModel.getValueAt(int(row),3).encode('utf-8').strip()
                    checklistStatus = self.dataModel.getValueAt(int(row),4).encode('utf-8').strip()
                    writer.writerow([checklistNumber, checklistCategory, checklistTestCase, checklistExample, checklistStatus])
            checklistdata.close()

    # function will handle to event once the import button clicked on vulnerablity tab
    def importvulnerability(self,e):
        chooseFile = JFileChooser()
        filter = FileNameExtensionFilter("csv files", ["csv"])
        chooseFile.addChoosableFileFilter(filter)
        
        ret = chooseFile.showDialog(self.tab, "Choose file")
        if ret == JFileChooser.APPROVE_OPTION:
            fileLoad = chooseFile.getSelectedFile()
            self.filepath = fileLoad.getAbsolutePath()
            
            #self.dataModel2.setRowCount(0)
            with open(self.filepath, 'rb') as f:
                reader2 = csv.reader(f,  delimiter=',')
                #self.data1 = list(reader)
                for rows in reader2:
                    URL = rows[0]
                    Parameter = rows[1]
                    Vulnerability = rows[2]
                    try:
                        Severity = rows[3]
                    except IndexError:
                        Severity = None

                    obj = [URL,Parameter,Vulnerability,Severity]
 
                    self.dataModel2.addRow(obj)
                    
                f.close()




# extending the default table model to remove the editable column from the checklist taB table
class CustomDefaultTableModelHosts(DefaultTableModel):

    # override isCellEditable method
    def isCellEditable(self, row, column):
        if column == 4:
            return 1
        else:
            return 0


# Extending the default table model for vulnerability tab column 0 (url) is not editable 
class CustomDefaultTableModelHosts2(DefaultTableModel):

    # override isCellEditable method
    def isCellEditable(self, row, column):
        if column == 0:
            return 0
        else:
            return 1





# Extedning the JTable for API Mapper TaB
class Table(JTable):
    def __init__(self, extender):
        self._extender = extender
        self.setModel(extender)
        self.setRowSelectionAllowed(True)
        self.setAutoCreateRowSorter(True)
        
        #self._txtInput = self._extender._txtInput
        
        
        #self.setColumnSelectionAllowed(True)
        
    # Only last colum is allowed for editing    
    def isCellEditable(self, row, column):
        if column == 4:
            return 1
        else:
            return 0
    
    # function that will change the request and test case for selected row
    def changeSelection(self, row, col, toggle, extend):
        self.modelRowIndex = self.convertRowIndexToModel(row)
        #self._extender.callbacks.printOutput(str(self.modelRowIndex))

        # show the log entry for the selected row
        #self._extender.getRowSorter().convertRowIndexToModel(row)
        self._extender._currentlySelectedLogTableRow = self.modelRowIndex
        logEntry = self._extender._log[int(self.modelRowIndex)]
        #logEntry = self._extender._log[row]
        #self._extender.requestViewer.setMessage(gettingrequest, True)
        self._extender.requestViewer.setMessage(
            logEntry._requestResponse, True)
        self._extender.responseViewer.setMessage(
            logEntry._response, True)
        text = logEntry._TestCases
        self._extender.testcases.setText(logEntry._TestCases)
        
       
        #self._extender._responseViewer.setMessage(logEntry._requestResponse.getResponse(), False)
        self._extender._currentlyDisplayedItem = logEntry._requestResponse
        JTable.changeSelection(self, row, col, toggle, extend)


#logger entry <- Class based python list to store the data for API Mapper tab/tabble
class LogEntry:
    def __init__(self, sr, url, method, postbody, requestResponse, FunctionalityName, TestCases, response):
        #self._tool = 'hdh'
        self._sr = sr
        self._url = url
        self._method = method
        self._postbody = postbody
        self._requestResponse = requestResponse
        self._FunctionalityName = FunctionalityName
        self._TestCases = TestCases
        self._response = response


#schedule.every(15).minutes.do(BurpExtender.trying)
